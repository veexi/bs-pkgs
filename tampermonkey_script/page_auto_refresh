// ==UserScript==
// @name         Page Auto Refresh
// @namespace    http://tampermonkey.net/
// @version      3.2.1-patch
// @description  仅在指定 drrr 房间页面生效的自动刷新脚本（持久化状态，面板可收起为小按钮并持久化） - 修复 UI 文本不可见问题 + 修复重载后立即触发循环刷新的 bug
// @author       ChatGPT (patched)
// @match        https://drrr.com/*
// @grant        none
// ==/UserScript==

(function () {
  'use strict';

  ////////////////////////////
  // --- 配置：目标页面 --- //
  ////////////////////////////
  const TARGET_ORIGIN = 'https://drrr.com';
  const TARGET_PATHNAME = '/room/';
  const TARGET_ID = 'sV0R7OkaTc';

  const currentNoHash = location.href.split('#')[0];
  const urlObj = (() => { try { return new URL(currentNoHash); } catch (e) { return null; } })();
  if (!urlObj || urlObj.origin !== TARGET_ORIGIN || urlObj.pathname !== TARGET_PATHNAME || urlObj.searchParams.get('id') !== TARGET_ID) {
    return;
  }

  ////////////////////////////
  // Inject UI-fix CSS (只改样式，不动逻辑) //
  ////////////////////////////
  (function injectUiFixCss() {
    const s = document.createElement('style');
    s.id = 'tm-auto-refresh-ui-fix-style';
    s.textContent = `
#tm-auto-refresh-panel, #tm-auto-refresh-panel * {
  color: #111 !important;
  -webkit-text-fill-color: #111 !important;
  text-shadow: none !important;
  opacity: 1 !important;
}
#tm-auto-refresh-toggle-btn {
  color: #fff !important;
  -webkit-text-fill-color: #fff !important;
}
#tm-auto-refresh-panel input,
#tm-auto-refresh-panel input::placeholder {
  color: #111 !important;
  -webkit-text-fill-color: #111 !important;
}
#tm-auto-refresh-panel button {
  text-shadow: none !important;
}
#tm-auto-refresh-panel {
  z-index: 999999 !important;
}
    `;
    document.head.appendChild(s);
  })();

  ////////////////////////////
  // --- 存储 key（绑定 id）--- //
  ////////////////////////////
  const KEY_SUFFIX = `__drrr_${TARGET_ID}`;
  const STORAGE_KEY = 'tm_auto_refresh_settings_v3' + KEY_SUFFIX;
  const RUNTIME_KEY = 'tm_auto_refresh_runtime_v3' + KEY_SUFFIX;
  const PANEL_KEY = 'tm_auto_refresh_panel_v3' + KEY_SUFFIX;

  const DEFAULTS = {
    intervalSeconds: 15,
    showTimer: true,
    stopAfter: 0,
    stopOnClick: false,
    hardRefresh: false,
    onlyWhenActive: false,
  };

  // ---------- 存取 ----------
  function loadSettings() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      return raw ? Object.assign({}, DEFAULTS, JSON.parse(raw)) : Object.assign({}, DEFAULTS);
    } catch (e) {
      return Object.assign({}, DEFAULTS);
    }
  }
  function saveSettings(s) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(Object.assign({}, DEFAULTS, s)));
  }
  function loadRuntime() {
    try {
      const raw = localStorage.getItem(RUNTIME_KEY);
      return raw ? JSON.parse(raw) : { running: false, nextFireAt: null, refreshCount: 0, pausedRemaining: null, lastRefreshAt: null };
    } catch (e) {
      return { running: false, nextFireAt: null, refreshCount: 0, pausedRemaining: null, lastRefreshAt: null };
    }
  }
  function saveRuntime(rt) {
    localStorage.setItem(RUNTIME_KEY, JSON.stringify(rt));
  }
  function loadPanelState() {
    try {
      const raw = localStorage.getItem(PANEL_KEY);
      return raw ? JSON.parse(raw) : { visible: true };
    } catch (e) {
      return { visible: true };
    }
  }
  function savePanelState(p) {
    localStorage.setItem(PANEL_KEY, JSON.stringify(p));
  }

  // ---------- 状态 ----------
  let settings = loadSettings();
  let runtime = loadRuntime();
  let panelState = loadPanelState();
  let tickIntervalId = null;
  let clickBound = false;

  // ---------- 修复点（归一化运行时 on load） ----------
  // 说明：如果脚本在上一页面设置了 running=true，但 nextFireAt 是过去的时间
  // 或者为空（页面在 reload 期间丢失或已经过期），会导致脚本在页面刚加载时立刻触发刷新，形成刷新循环。
  // 我们在初始化阶段确保：
  //  1) 如果 runtime.running 且 nextFireAt 为 null/过期 -> 将 nextFireAt 设置为现在 + interval
  //  2) 增加对 document.readyState 的检测，避免在页面未完成加载（complete）时触发刷新
  function normalizeRuntimeOnLoad() {
    try {
      if (!runtime || !runtime.running) return;
      const interval = settings.intervalSeconds || DEFAULTS.intervalSeconds;
      // 如果 nextFireAt 不存在或已经在过去（<= Date.now），则推后到未来。
      if (!runtime.nextFireAt || runtime.nextFireAt <= Date.now()) {
        runtime.nextFireAt = Date.now() + Math.max(1, interval) * 1000;
        runtime.pausedRemaining = null;
        saveRuntime(runtime);
      }
    } catch (e) {
      console.error('normalizeRuntimeOnLoad error', e);
    }
  }

  // ---------- UI（面板 + 小按钮） ----------
  const panel = document.createElement('div');
  panel.id = 'tm-auto-refresh-panel';
  panel.style.cssText = `
    position: fixed; right: 18px; bottom: 18px; width: 320px;
    background: #fff; border: 2px solid #2dbb9b; border-radius: 10px;
    padding: 12px; box-shadow: 0 6px 18px rgba(0,0,0,0.12); z-index:999999;
    font-family: Arial, Helvetica, sans-serif; font-size:13px;
  `;
  panel.innerHTML = `
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
      <strong>Auto Refresh</strong>
      <div style="display:flex;gap:6px;align-items:center">
        <button id="tm-minimize" title="收起面板" style="border:none;background:#2dbb9b;color:#fff;padding:6px 8px;border-radius:6px;cursor:pointer">Close</button>
      </div>
    </div>

    <div style="margin-bottom:8px">
      <div style="margin-bottom:6px"><label>Interval (H:M:S)</label></div>
      <div style="display:flex;gap:6px;margin-bottom:6px">
        <input id="tm-hours" type="number" min="0" style="width:70px;padding:6px;border:1px solid #ccc;border-radius:6px" placeholder="Hour">
        <input id="tm-mins" type="number" min="0" max="59" style="width:70px;padding:6px;border:1px solid #ccc;border-radius:6px" placeholder="Min">
        <input id="tm-secs" type="number" min="0" max="59" style="width:70px;padding:6px;border:1px solid #ccc;border-radius:6px" placeholder="Sec">
      </div>
      <div style="display:flex;gap:6px;margin-bottom:6px">
        <button class="tm-preset" data-secs="5">5 Sec</button>
        <button class="tm-preset" data-secs="10">10 Sec</button>
        <button class="tm-preset" data-secs="15">15 Sec</button>
      </div>
      <div style="display:flex;gap:6px;margin-bottom:6px">
        <button class="tm-preset" data-secs="300">5 Min</button>
        <button class="tm-preset" data-secs="600">10 Min</button>
        <button class="tm-preset" data-secs="900">15 Min</button>
      </div>
    </div>

    <div style="margin-bottom:8px">
      <div style="font-weight:600;margin-bottom:6px">Advance Options</div>
      <label><input id="tm-stop-after-check" type="checkbox"> Stop after </label>
      <input id="tm-stop-after-num" type="number" min="1" style="width:60px;padding:4px;margin-left:6px" placeholder="3"> times
      <div style="margin-top:6px"><label><input id="tm-show-timer" type="checkbox"> Show visual timer on page</label></div>
      <div><label><input id="tm-stop-on-click" type="checkbox"> Stop refreshing if click anywhere on the page</label></div>
      <div><label><input id="tm-hard-refresh" type="checkbox"> Hard Refresh (cache bust)</label></div>
      <div><label><input id="tm-only-active" type="checkbox"> Only refresh when tab is active</label></div>
    </div>

    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <button id="tm-start" style="padding:8px 12px;border-radius:8px;border:1px solid #2dbb9b;background:#2dbb9b;color:#fff;cursor:pointer">Start</button>
        <button id="tm-stop" style="padding:8px 12px;border-radius:8px;border:1px solid #ccc;background:#fff;color:#333;cursor:pointer;margin-left:6px">Stop</button>
      </div>
      <div>
        <button id="tm-save" style="padding:8px 12px;border-radius:8px;border:none;background:#2dbb9b;color:#fff;cursor:pointer">Save</button>
      </div>
    </div>
    <div style="margin-top:8px;font-size:12px;color:#666">
      <span id="tm-status">Status: Stopped</span>
      <span id="tm-timer-display" style="float:right"></span>
    </div>
  `;
  document.body.appendChild(panel);

  const smallBtn = document.createElement('button');
  smallBtn.id = 'tm-auto-refresh-toggle-btn';
  smallBtn.title = '打开 Auto Refresh 面板';
  smallBtn.style.cssText = `
    position: fixed; right: 18px; bottom: 18px; width:56px; height:56px;
    border-radius:28px; border:none; box-shadow:0 6px 18px rgba(0,0,0,0.12);
    background:#2dbb9b; color:#fff; font-weight:700; z-index:1000000; cursor:pointer;
    display:none;
  `;
  smallBtn.textContent = 'AR';
  document.body.appendChild(smallBtn);

  const $hours = panel.querySelector('#tm-hours');
  const $mins = panel.querySelector('#tm-mins');
  const $secs = panel.querySelector('#tm-secs');
  const $presets = panel.querySelectorAll('.tm-preset');
  const $start = panel.querySelector('#tm-start');
  const $stop = panel.querySelector('#tm-stop');
  const $save = panel.querySelector('#tm-save');
  const $status = panel.querySelector('#tm-status');
  const $timerDisplay = panel.querySelector('#tm-timer-display');
  const $showTimer = panel.querySelector('#tm-show-timer');
  const $stopAfterCheck = panel.querySelector('#tm-stop-after-check');
  const $stopAfterNum = panel.querySelector('#tm-stop-after-num');
  const $stopOnClick = panel.querySelector('#tm-stop-on-click');
  const $hardRefresh = panel.querySelector('#tm-hard-refresh');
  const $onlyActive = panel.querySelector('#tm-only-active');
  const $minimize = panel.querySelector('#tm-minimize');

  let visualEl = null;
  function createVisualTimer() {
    if (visualEl) return;
    visualEl = document.createElement('div');
    visualEl.style.cssText = 'position:fixed;left:10px;bottom:10px;padding:8px 12px;border-radius:6px;background:rgba(45,187,155,0.9);color:#fff;z-index:999999;font-weight:600;';
    document.body.appendChild(visualEl);
  }
  function removeVisualTimer() {
    if (!visualEl) return;
    visualEl.remove();
    visualEl = null;
  }

  function secsFromInputs() {
    const h = Math.max(0, parseInt($hours.value || 0, 10));
    const m = Math.max(0, parseInt($mins.value || 0, 10));
    const s = Math.max(0, parseInt($secs.value || 0, 10));
    return h * 3600 + m * 60 + s;
  }
  function formatHMS(total) {
    if (total < 0) total = 0;
    const h = Math.floor(total / 3600);
    const m = Math.floor((total % 3600) / 60);
    const s = Math.floor(total % 60);
    return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  }

  function updateUIFromSettings() {
    $hours.value = Math.floor(settings.intervalSeconds / 3600) || '';
    $mins.value = Math.floor((settings.intervalSeconds % 3600) / 60) || '';
    $secs.value = settings.intervalSeconds % 60 || '';
    $showTimer.checked = !!settings.showTimer;
    $stopAfterCheck.checked = !!(settings.stopAfter > 0);
    $stopAfterNum.value = settings.stopAfter || '';
    $stopOnClick.checked = !!settings.stopOnClick;
    $hardRefresh.checked = !!settings.hardRefresh;
    $onlyActive.checked = !!settings.onlyWhenActive;
  }

  function updateStatusText() {
    $status.textContent = `Status: ${runtime.running ? 'Running' : 'Stopped'} / Refreshes: ${runtime.refreshCount || 0}`;
  }
  function updateTimerDisplay() {
    let remainingSec = computeRemainingSeconds();
    $timerDisplay.textContent = runtime.running ? `Next: ${formatHMS(Math.ceil(remainingSec))}` : '';
    if (settings.showTimer) {
      createVisualTimer();
      visualEl.textContent = runtime.running ? `刷新倒计时 ${formatHMS(Math.ceil(remainingSec))}` : '未运行';
    } else {
      removeVisualTimer();
    }
  }

  function computeRemainingSeconds() {
    if (!runtime.running) return 0;
    if (runtime.pausedRemaining != null) return Math.max(0, Math.ceil(runtime.pausedRemaining / 1000));
    if (!runtime.nextFireAt) return 0;
    return Math.max(0, Math.ceil((runtime.nextFireAt - Date.now()) / 1000));
  }

  function bindStopOnClickIfNeeded() {
    if ($stopOnClick.checked && !clickBound) {
      document.addEventListener('click', stopOnClickHandler, { capture: true });
      clickBound = true;
    }
    if (!$stopOnClick.checked && clickBound) {
      document.removeEventListener('click', stopOnClickHandler, { capture: true });
      clickBound = false;
    }
  }
  function unbindStopOnClick() {
    if (clickBound) {
      document.removeEventListener('click', stopOnClickHandler, { capture: true });
      clickBound = false;
    }
  }
  function stopOnClickHandler() {
    stopAutoRefresh();
  }

  function ensureTickRunning() {
    if (tickIntervalId) return;
    tickIntervalId = setInterval(() => {
      try {
        // 如果页面还没完全加载完成，不去做触发刷新（避免在文档未完成时发生 reload 循环）
        if (document.readyState !== 'complete') {
          updateTimerDisplay();
          return;
        }

        if (!runtime.running) {
          updateTimerDisplay();
          return;
        }
        if (settings.onlyWhenActive && document.hidden && runtime.pausedRemaining == null && runtime.nextFireAt) {
          runtime.pausedRemaining = Math.max(0, runtime.nextFireAt - Date.now());
          runtime.nextFireAt = null;
          saveRuntime(runtime);
          updateTimerDisplay();
          return;
        }
        if (settings.onlyWhenActive && !document.hidden && runtime.pausedRemaining != null) {
          runtime.nextFireAt = Date.now() + runtime.pausedRemaining;
          runtime.pausedRemaining = null;
          saveRuntime(runtime);
        }

        const now = Date.now();
        if (runtime.nextFireAt && now >= runtime.nextFireAt) {
          // 到时间 -> 执行刷新逻辑
          runtime.refreshCount = (runtime.refreshCount || 0) + 1;
          // 记录最后一次刷新时间，防止短时间内重复触发
          runtime.lastRefreshAt = runtime.lastRefreshAt || 0;
          // 如果上次刷新时间在 2 秒内，认为是重复快速触发，先把 nextFireAt 推后
          if (runtime.lastRefreshAt && (now - runtime.lastRefreshAt) < 2000) {
            runtime.nextFireAt = Date.now() + Math.max(1, settings.intervalSeconds || DEFAULTS.intervalSeconds) * 1000;
            saveRuntime(runtime);
            updateTimerDisplay();
            return;
          }

          saveRuntime(runtime);

          if (settings.stopAfter > 0 && (runtime.refreshCount || 0) >= settings.stopAfter) {
            runtime.running = false;
            saveRuntime(runtime);
            doRefresh(); // 最后一次刷新（会 reload，因此脚本结束）
            return;
          } else {
            doRefresh();
            return;
          }
        } else {
          updateTimerDisplay();
        }
      } catch (e) {
        console.error('tm tick error', e);
      }
    }, 900);
  }
  function clearTick() {
    if (tickIntervalId) {
      clearInterval(tickIntervalId);
      tickIntervalId = null;
    }
  }

  function doRefresh() {
    // 防御性检查：如果页面未完全加载或者刚刚刷新过（2s 内），跳过以免进入循环
    if (document.readyState !== 'complete') return;
    if (runtime.lastRefreshAt && (Date.now() - runtime.lastRefreshAt) < 2000) return;

    runtime.lastRefreshAt = Date.now();
    saveRuntime(runtime);

    if (settings.onlyWhenActive && !document.hasFocus()) {
      return;
    }
    if (settings.hardRefresh) {
      const url = new URL(location.href);
      url.searchParams.set('_tmr', Date.now());
      location.href = url.toString();
    } else {
      location.reload();
    }
  }

  function startAutoRefreshFromUI() {
    const interval = secsFromInputs();
    if (!interval || interval <= 0) {
      alert('请设置有效的刷新间隔（大于0秒）');
      return;
    }
    settings.intervalSeconds = interval;
    settings.showTimer = !!$showTimer.checked;
    settings.stopAfter = $stopAfterCheck.checked ? (Math.max(1, parseInt($stopAfterNum.value || 0, 10) || 0)) : 0;
    settings.stopOnClick = !!$stopOnClick.checked;
    settings.hardRefresh = !!$hardRefresh.checked;
    settings.onlyWhenActive = !!$onlyActive.checked;
    saveSettings(settings);

    if (!runtime.running) runtime.refreshCount = runtime.refreshCount || 0;
    runtime.running = true;
    runtime.nextFireAt = Date.now() + interval * 1000;
    runtime.pausedRemaining = null;
    saveRuntime(runtime);

    bindStopOnClickIfNeeded();
    ensureTickRunning();
    updateStatusText();
    updateTimerDisplay();
  }

  function stopAutoRefresh(byUser) {
    runtime.running = false;
    runtime.nextFireAt = null;
    runtime.pausedRemaining = null;
    saveRuntime(runtime);
    unbindStopOnClick();
    clearTick();
    updateStatusText();
    updateTimerDisplay();
  }

  function showPanel() {
    panel.style.display = 'block';
    smallBtn.style.display = 'none';
    panelState.visible = true;
    savePanelState(panelState);
  }
  function hidePanelToButton() {
    panel.style.display = 'none';
    smallBtn.style.display = 'block';
    panelState.visible = false;
    savePanelState(panelState);
  }

  smallBtn.addEventListener('click', () => {
    showPanel();
  });
  $minimize.addEventListener('click', () => {
    hidePanelToButton();
  });

  $presets.forEach(btn => {
    btn.style.cssText = 'padding:6px 8px;border-radius:6px;border:1px solid #cfd8d8;background:#f6fefe;cursor:pointer';
    btn.addEventListener('click', () => {
      const s = parseInt(btn.getAttribute('data-secs'), 10);
      $hours.value = Math.floor(s / 3600) || '';
      $mins.value = Math.floor((s % 3600) / 60) || '';
      $secs.value = s % 60 || '';
    });
  });

  $start.addEventListener('click', () => startAutoRefreshFromUI());
  $stop.addEventListener('click', () => stopAutoRefresh(true));
  $save.addEventListener('click', () => {
    settings.showTimer = !!$showTimer.checked;
    settings.stopAfter = $stopAfterCheck.checked ? (Math.max(1, parseInt($stopAfterNum.value || 0, 10) || 0)) : 0;
    settings.stopOnClick = !!$stopOnClick.checked;
    settings.hardRefresh = !!$hardRefresh.checked;
    settings.onlyWhenActive = !!$onlyActive.checked;
    const interval = secsFromInputs();
    if (interval > 0) settings.intervalSeconds = interval;
    saveSettings(settings);
    alert('已保存设置');
    bindStopOnClickIfNeeded();
  });

  document.addEventListener('visibilitychange', () => {
    if (!settings.onlyWhenActive) return;
    if (document.hidden && runtime.running && runtime.pausedRemaining == null && runtime.nextFireAt) {
      runtime.pausedRemaining = Math.max(0, runtime.nextFireAt - Date.now());
      runtime.nextFireAt = null;
      saveRuntime(runtime);
    } else if (!document.hidden && runtime.running && runtime.pausedRemaining != null) {
      runtime.nextFireAt = Date.now() + runtime.pausedRemaining;
      runtime.pausedRemaining = null;
      saveRuntime(runtime);
    }
    updateTimerDisplay();
  });

  // ---------- 初始化 ----------
  settings = Object.assign({}, settings, loadSettings());
  runtime = Object.assign({}, runtime, loadRuntime());
  panelState = Object.assign({}, panelState, loadPanelState());

  // 关键修复：初始化时归一化 runtime.nextFireAt，避免过期时间导致立即刷新
  normalizeRuntimeOnLoad();

  updateUIFromSettings();
  updateStatusText();
  updateTimerDisplay();

  if (panelState.visible) {
    panel.style.display = 'block';
    smallBtn.style.display = 'none';
  } else {
    panel.style.display = 'none';
    smallBtn.style.display = 'block';
  }

  if (runtime.running) {
    bindStopOnClickIfNeeded();
    ensureTickRunning();
    updateStatusText();
    updateTimerDisplay();
  }

  window.addEventListener('beforeunload', () => {
    saveSettings(settings);
    saveRuntime(runtime);
    savePanelState(panelState);
  });

})();
